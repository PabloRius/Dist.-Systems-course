/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "servicio.h"
#include <stdbool.h>
#include <stdlib.h>
#include <string.h>

#include "ABB.h"
#include "utils.h"

#define INIT 0
#define GET 1
#define SET 2
#define MODIFY 3
#define DELETE 4
#define EXIST 5

struct Tree *tree;
int initialized = 0;

pthread_t thid;
pthread_attr_t attr;

struct params_pack {
	struct args_in in;
	struct args_out *out;
};

bool_t init(struct params_pack params)
{
    printf("Servicio init\n");

    // Inicializamos la respuesta
    int res = 0;

    // Comprobar que la estructura de datos no está poblada / reiniciarla
    if (tree != NULL)
    {
        free(tree);
    }

    // Iniciar la estructura de datos
    if (init_tree(&tree) == -1)
    {
        printf("Error inicializando el árbol\n");
        res = -1;
    }
    else
    {
        initialized = 1;
        printf("Árbol inicializado\n");
    }

	params.out->code = res;
    
    return true;
}

bool_t get_tuple(struct params_pack params)
{
    printf("Servicio get\n");

    // Inicializamos la respuesta
    int res = 0;

    // Comprobar que la estructura de datos está poblada
    if (initialized == 0)
    {
        res = -1;
    }

    // Buscamos el nodo con la clave recibida
    printf("%d\n", params.in.key);
    if (get_node(tree, params.in.key, params.out->cadena, &params.out->N, params.out->vector) == -1)
    {
        printf("Error buscando el nodo: %d\n", params.in.key);
        res = -1;
    }
    else
    {
        printf("Nodo encontrado\n");
    }
    
    params.out->code = res;
    return true;
}

bool_t set_tuple(struct params_pack params)
{
    printf("Servicio set\n");

    // Inicializamos la respuesta
    int res = 0;

    // Comprobar que la estructura de datos está poblada
    if (initialized == 0)
    {
        res = -1;
    }

    // Buscamos el nodo con la clave recibida
    if (post_node(tree, params.in.key, params.in.cadena, params.in.N, params.in.vector) == -1)
    {
        printf("Error insertando el nodo\n");
        res = -1;
    }
    else
    {
        printf("Nodo insertado\n");
        print_tree(tree, 1);
    }
    
    params.out->code = res;
    return true;
}

bool_t modify_tuple(struct params_pack params)
{
    printf("Servicio modify\n");

    // Inicializamos la respuesta
    int res = 0;

    // Comprobar que la estructura de datos está poblada
    if (initialized == 0)
    {
        res = -1;
    }

    // Buscamos el nodo con la clave recibida
    if (patch_node(tree, params.in.key, params.in.cadena, params.in.N, params.in.vector) == -1)
    {
        printf("Error modificando el nodo\n");
        res = -1;
    }
    else
    {
        printf("Nodo modificado\n");
        print_tree(tree, 1);
    }
    
    params.out->code = res;
    return true;
}

bool_t delete_tuple(struct params_pack params)
{
    printf("Servicio delete\n");

    // Inicializamos la respuesta
    int res = 0;

    // Comprobar que la estructura de datos está poblada
    if (initialized == 0)
    {
        res = -1;
    }

    // Buscamos el nodo con la clave recibida
    if (delete_node(tree, params.in.key) == -1)
    {
        printf("Error eliminando el nodo\n");
        res = -1;
    }
    else
    {
        printf("Nodo eliminado\n");
        print_tree(tree, 1);
    }
    
    params.out->code = res;
    return true;
}

bool_t exist_tuple(struct params_pack params)
{
    printf("Servicio exist\n");

    // Inicializamos la respuesta
    int res = 0;

    // Comprobar que la estructura de datos está poblada
    if (initialized == 0)
    {
        res = -1;
    }

    res = head_node(tree, params.in.key);
    
    params.out->code = res;
    return true;
}

bool_t
servicios_1_svc(struct args_in arg1, struct args_out *result,  struct svc_req *rqstp)
{
	bool_t retval; 

	printf("Operación: %d\n", arg1.op);
	
	struct params_pack params;

	params.in = arg1;
	params.out = result;

    retval = true;

	switch (arg1.op)
    {
        case INIT:
            retval = init(params);
            break;

        case GET:
            retval = get_tuple(params);
            break;

        case SET:
            retval = set_tuple(params);
            break;

        case MODIFY:
            retval = modify_tuple(params);
            break;

        case DELETE:
            retval = delete_tuple(params);
            break;

        case EXIST:
            retval = exist_tuple(params);
            break;

        // Definir código de operación incorrecto
        default:
            printf("Error al registrar el número de operación: %d\n", arg1.op);

            break;
        }
	return retval;
}

int
servicio_1_freeresult (SVCXPRT *transp, xdrproc_t xdr_result, caddr_t result)
{
	xdr_free (xdr_result, result);

	/*
	 * Insert additional freeing code here, if needed
	 */

	return 1;
}
